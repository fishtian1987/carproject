/*
*********************************************************************************************************
*	                                  
*	模块名称 : 共有部分模块
*	文件名称 : combug.c
*	版    本 : V1.3
*	说    明 : 共有部分模块
*
*
*********************************************************************************************************
*/

#include "combug.h"

/*
*********************************************************************************************************
*	函 数 名: dataFusion
*	功能说明: 数据融合
*	形    参：addr,地址
						len,长度
*	返 回 值: 结果
*********************************************************************************************************
*/
//int32_t dataFusion(u8* addr,u8 len)
//{
//	int32_t temp=0;
//	int32_t _temp=0;
//	u8 i=0,j=len-1;
//	for(i=0;i<len;i++)
//	{
//		temp=addr[i];
//		_temp|=temp<<(j-i)*8;
//	}
//	return _temp;
//}

/*
*********************************************************************************************************
*	函 数 名: Data_Pow
*	功能说明: m^n函数
*	形    参：m,底
						n,幂
*	返 回 值: m^n次方.
*********************************************************************************************************
*/
u32 Data_Pow(u8 m,u8 n)
{
	u32 result=1;	 
	while(n--)result*=m;    
	return result;
}

/*
*********************************************************************************************************
*	函 数 名: dataDiv
*	功能说明: 拆分数据
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
//void dataDiv(int32_t data,u8 len,int32_t *dataf,int32_t *datab)
//{
//	u32 temp=Data_Pow(10,len);
//	*dataf=data/temp;
//	*datab=data%temp;
//}

/*
*********************************************************************************************************
*	函 数 名: BCD_DataProcess
*	功能说明: 处理压缩BCD码数据
*	形    参：addr,地址;len,长度;cmd,高位标志(符号或数据)
*	返 回 值: 解算结果
*********************************************************************************************************
*/
int32_t BCD_DataProcess(u8 *addr,u8 len,bool cmd)
{
	int8_t factor=1;
	int32_t _temp=0;
	if(cmd)
	{
		if((*addr&0xF0)== 16) 
			factor=-1;
	}
	else
	{
		_temp+=(*(addr)>>4)*Data_Pow(10,2*len-1);
	}
	_temp+=(*addr&0x0F)*Data_Pow(10,2*len-2);

	for(u8 i=1;i<len;i++)
	{
		_temp+=(*(addr+i)>>4)*Data_Pow(10,2*(len-i)-1);
		_temp+=(*(addr+i)&0x0F)*Data_Pow(10,2*(len-i)-2);
	}
	return _temp*factor;
}
